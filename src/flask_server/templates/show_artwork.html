{% extends 'base.html' %}

{% block content %}
<!-- Main body -->
<div class="container">
<!-- 
1. Load three.js environment 
    https://www.reddit.com/r/threejs/comments/v5huuo/using_flask_with_threejs/
2. Show a demo polygon 
3. Show a polygon from a web request 
-->

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
<style>
    body {
        background-color: #f0f0f0;
        color: #444;
    }
</style>

<div id="info">Artwork</div>
<!--     {{simple_box}}  -->
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
    {
        "imports": {
            "three": "../static/repos/three.js/build/three.module.js",
            "three/addons/": "../static/repos/three.js/examples/jsm/"
        }
    }
</script>

<script type="module">
    // console.log("printing artwork: ") 
    // console.log(simple_box) 
    // console.log(artwork) 
    import * as THREE from 'three';
    import Stats from 'three/addons/libs/stats.module.js';

    let container, stats;
    let camera, scene, renderer;
    let group;
    let targetRotation = 0;
    let targetRotationOnPointerDown = 0;
    let pointerX = 0;
    let pointerXOnPointerDown = 0;

    let windowHalfX = window.innerWidth / 2;

    init();
    animate();

    function init() {
        var myArtwork;

        function fetchArtwork(){
            return fetch('/serve_artwork')
                .then(response => response.json())
                .then(data => {
                    //const simple_box = data.simple_box;
                    const myArtwork = data.simple_box;
                    console.log('printing simple box')
                    console.log(myArtwork);
                    console.log('printed simple box');
                    return myArtwork;
                });    
            
        }

        fetchArtwork().then(server_artwork => {
            console.log(server_artwork);
            console.log(' do something with the variable here');
        });


        console.log('printing simple box2 ');
        console.log(myArtwork);
        console.log('printed simple box2');

        
        container = document.createElement( 'div' );
        document.body.appendChild( container );

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xf0f0f0 );

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( 0, 150, 500 );
        scene.add( camera );

        const light = new THREE.PointLight( 0xffffff, 0.8 );
        camera.add( light );

        group = new THREE.Group();
        group.position.y = 150; 
        group.position.x = 175; 
        scene.add( group ); 

        const loader = new THREE.TextureLoader(); 
        const texture = loader.load( 'textures/uv_grid_opengl.jpg' ); 

        // it's necessary to apply these settings in order to correctly display the texture on a shape geometry
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set( 0.008, 0.008 );

        function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {

            // flat shape with texture
            // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

            let geometry = new THREE.ShapeGeometry( shape ); 

            let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } ) );
            // mesh.position.set( x, y, z - 175 );
            // mesh.rotation.set( rx, ry, rz );
            // mesh.scale.set( s, s, s );
            // group.add( mesh );

            // flat shape
            // geometry = new THREE.ShapeGeometry( shape );
            // mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
            // mesh.position.set( x, y, z - 125 );
            // mesh.rotation.set( rx, ry, rz );
            // mesh.scale.set( s, s, s );
            // group.add( mesh );

            // extruded shape
            geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
            mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );
            mesh.position.set( x, y, z - 75 );
            mesh.rotation.set( rx, ry, rz );
            mesh.scale.set( s, s, s );
            group.add( mesh );

            addLineShape( shape, color, x, y, z, rx, ry, rz, s );

        }

        function addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {

            // lines

            shape.autoClose = true;

            const points = shape.getPoints();
            //const spacedPoints = shape.getSpacedPoints( 50 );

            //const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
            //const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );

            // solid line

            // let line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
            // line.position.set( x, y, z - 25 );
            // line.rotation.set( rx, ry, rz );
            // line.scale.set( s, s, s );
            // group.add( line );

            // line from equidistance sampled points

            // line = new THREE.Line( geometrySpacedPoints, new THREE.LineBasicMaterial( { color: color } ) );
            // line.position.set( x, y, z + 25 );
            // line.rotation.set( rx, ry, rz );
            // line.scale.set( s, s, s );
            // group.add( line );

            // vertices from real points

            // let particles = new THREE.Points( geometryPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
            // particles.position.set( x, y, z + 75 );
            // particles.rotation.set( rx, ry, rz );
            // particles.scale.set( s, s, s );
            // group.add( particles );

            // equidistance sampled points

            // particles = new THREE.Points( geometrySpacedPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
            // particles.position.set( x, y, z + 125 );
            // particles.rotation.set( rx, ry, rz );
            // particles.scale.set( s, s, s );
            // group.add( particles );

        }

        var design_pts = [[0,0], [200,0], [200, 200], [0,200], [0,0]];
        const californiaPts = [];
        
        for ( let i = 0; i < design_pts.length; i ++ ){
            californiaPts.push(new THREE.Vector2( 
                design_pts[i][0], design_pts[i][1]
            )); 
        } 
        //for ( let i = 0; i < design_pts.length; i ++ ) console.log(new THREE.Vector2( design_pts[i] ).x);
        for ( let i = 0; i < californiaPts.length; i ++ ) californiaPts[ i ].multiplyScalar( 0.25 );
        const californiaShape = new THREE.Shape( californiaPts );

        const extrudeSettings = { depth: 4, bevelEnabled: true, bevelSegments: 2, steps: 1, bevelSize: 1, bevelThickness: 1 };
        // addShape( shape, color, x, y, z, rx, ry,rz, s );
        addShape( californiaShape, extrudeSettings, 0xf08000, - 300, - 100, 0, 0, 0, 0, 1 );

        // 

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        container.style.touchAction = 'none';
        container.addEventListener( 'pointerdown', onPointerDown );

        //

        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onPointerDown( event ) {

        if ( event.isPrimary === false ) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener( 'pointermove', onPointerMove );
        document.addEventListener( 'pointerup', onPointerUp );

    }

    function onPointerMove( event ) {

        if ( event.isPrimary === false ) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

    }

    function onPointerUp() {

        if ( event.isPrimary === false ) return;

        document.removeEventListener( 'pointermove', onPointerMove );
        document.removeEventListener( 'pointerup', onPointerUp );

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {

        group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
        renderer.render( scene, camera );

    }

</script>





</div> 

{% endblock %}